#ifndef _MDB_MODELS
#define _MDB_MODELS
#include <stdbool.h>
#include "../types/types.h"
#include "../utils/utils.h"
#include "../struct/structs.h"

// Macros
#define _MDB_DB_OBJECT_NAME_SIZE 100
#define _MDB_DB_OBJECT_COLUMN_NAME_SIZE 100

// Enums
typedef enum Permission_t {
	NONE = 0,
	READ = 1,
	WRITE = 1 << 1,
	UPDATE = 1 << 2,
	DELETE = 1 << 3,
	CREATE = 1 << 4,
	DROP = 1 << 5
} permission_t;

typedef enum Operator_t {
	OP_EQUALS,
	OP_LESS,
	OP_GREAT,
	OP_LESS_EQUALS,
	OP_GREAT_EQUALS,
	OP_DIFFERENT,
	OP_LIKE,
	OP_NOT,
	OP_AND,
	OP_OR,
	OP_XOR,
	NO_OP
} operator_t;

typedef enum Modifiers_t {
	MOD_REQUIRED = 0,
	MOD_OPTIONAL = 1,
	MOD_PRIMARY_KEY = 1 << 1,
	MOD_FOREIGN_KEY = 1 << 2,
	MOD_CALCULATED = 1 << 3,
	MOD_AUTOGENERATED = 1 << 4
} modifier_t;

typedef enum Generator_t {
	NO_GENERATOR,
	DEFAULT_VALUE,
	AUTOINCREMENTAL,
	UUID_V4,
	UUID_V6,
	USE_SEQUENCE
} generator_t;

// Structs
// USER
typedef struct User_t {
	types_t o;
} user_t;
// SESSION
typedef struct Session_t {
	types_t o;

} sesion_t;
// SCHEMA
typedef struct Schema_t {
	types_t o;

} schema_t;
// ROLE
typedef struct Role_t {
	types_t o;

} role_t;
// CONDITION
typedef struct Condition_t {
	types_t o;
	operator_t op;
	void *left, *right;
} condition_t;
// SEQUENCE
typedef struct Sequence_t {
	types_t o;
	double begin, end, current;
	float step;
	bool isLoop, isEnd;
} sequence_t;
// FUNCTION
typedef struct Function_t {
	types_t o;
	char name[_MDB_DB_OBJECT_NAME_SIZE];
	char *alias;
	linked_list_t *args;
	result_t *(*execute)(linked_list_t*);
} function_t;
// COLUMN
typedef struct Column_t {
	types_t o;
	data_type_t *type;
	char name[_MDB_DB_OBJECT_COLUMN_NAME_SIZE];
	unsigned int modifiers:5;
	generator_t generator_type;
	void *generator;
} column_t;
// TABLE
typedef struct Table_t {
	types_t o;
	int id;
	char name[_MDB_DB_OBJECT_NAME_SIZE];
	column_t **columns;
	int column_count;
	set_t *rows;
	hash_map_t *indexes;
} table_t;
typedef struct Select_table_t {
	column_t **columns;
	int group_count;
	int column_count;
	set_t **rows;
} select_table_t;
// VIEW
typedef struct View_t {
	types_t o;

} view_t;
// INDEX
typedef struct Index_t {
	types_t o;
	binary_tree_t indexed;
} index_t;
// PROCEDURE
typedef struct Procedure_t {
	types_t o;

} procedure_t;

// Functions
// FUNCTION
function_t *clone_function(const function_t);
void function_set_alias(function_t*, const char*);
char *function_to_string(const function_t);
// SESSION
// SCHEMA
// ROLE
// CONDITIONS
condition_t *new_condition(operator_t, void*, void*);
bool eval_condition(const condition_t, const hash_map_t);
char *condition_to_string(condition_t);
// SEQUENCE
sequence_t *new_sequence(double, double, float, bool);
sequence_t *clone_sequence(const sequence_t);
result_t *use_sequence(sequence_t*);
// COLUMNS
column_t *new_column(const char*, modifier_t, data_type_t*, generator_t, void*);
compare_result_t compare_column(column_t, const char*);
char *column_to_string(column_t);
// TABLE
table_t *new_table(const char*, int, column_t**);
table_t *clone_table(table_t);
table_t *delete_table(table_t*);
char *table_to_string(table_t);
result_t *table_insert(table_t*, int, hash_map_t**);
result_t *table_update(table_t*, condition_t*, linked_list_t*);
result_t *table_delete(table_t*, condition_t*);
// TABLE SELECTION OPTIONS
result_t *table_select(table_t, condition_t*);
result_t *table_group(select_table_t, const char*);
result_t *table_having(select_table_t, linked_list_t);
result_t *table_proyect(select_table_t, linked_list_t);
result_t *table_order(select_table_t, linked_list_t);
result_t *table_limit(select_table_t, linked_list_t);
void show_table_select(const select_table_t);
// VIEW
// INDEX
// PROCEDURE

#endif
